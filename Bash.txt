Если вы начнете набирать название папки и нажмете Tab, система сама его подставит. 
Если просто нажмете Tab, ничего не вводя, система начнет перебирать возможные варианты

Кроме того, существуют команды для быстрого перемещения по командной строке и быстрого удаления текста: 
●	Ctrl-A — в начало строки.
●	Ctrl-E — в конец строки.
●	Alt-F — на слово вперед.
●	Alt-B — на слово назад.
●	Ctrl-U — удалить в строке все символы от текущей позиции до начала строки.
●	Ctrl-K — удалить в строке все символы от текущей позиции до конца строки.

И еще четыре важных для работы в терминале комбинации:
●	Ctrl-S остановит вывод на терминал. Иногда комбинацию используют при выводе больших объемов текста на терминал для временной остановки вывода. Бывает, что эту комбинацию нажимают случайно и тогда терминал как будто зависает. Не спешите паниковать, просто выполните следующую комбинацию.
●	Ctrl-Q продолжает вывод после Ctrl-S. Если кажется, что терминал завис, в первую очередь попробуйте эту комбинацию.
●	Ctrl-C завершает работу текущей программы. Используют, когда надо быстро завершить работу текущей программы или скрипта. Программа не всегда может  завершиться после Ctrl-C: иногда реакцию на эту комбинацию в программе или скрипте намеренно блокируют.
●	Ctrl-R — для поиска по истории команд.


mc - вызов файлового менеджера Midnight Commander
env - переменные окружения
echo $PATH - список исполняемых файлов

w - узнать кто залогинен в системе
id - инфо о пользователе
pwd - текущее местонахождение
cd - переход к директории
~ или ~/ — домашний каталог или путь относительно него. 
. или ./ —  текущий каталог или путь относительно текущего. 
.. или ../ —  родительский каталог или путь от родительского каталога.
~user — домашний каталог пользователя user.
~- — предыдущий посещенный каталог.
~+ — путь текущего каталога
cd / - переход к корневому каталогу
cd - - вернуться к предыдущему каталогу
cd ~ - перейти к домашнему каталогу
cd .. - перейти на одну директорию выше
cd ../.. - перейти на 2 директории выше

clear - очистить консоль

ls - содержание папки в которой находимся
ls -l - вывод колонки с доп инфо о файлах(в выводе 1 столбца 1 символ: d - директория, "-" - файлы)
ls -L - подробное содержпние папки в которой находимся
ls -t - сортировка по времени изменения файла или директории(свежие файлы внизу)
ls -r обратная сортировка
ls -a - показать скрытые папки и файлы
ls -A - показать скрытые папки и файлы, кроме системных
ls -d - показать директории без их внутренностей
ls имя_папки - отобразить содержание указанной папки
ls -lad ./.* - содержание папки с именами подходящими под regex выражение
Можно комбинировать ключи: ls -a -l тоже самое, что и ls -al или ls -la

man имя_команды - вывод справки по команде. Например man ls. Чтобы выйти необходимо нажать на кнопку "q"

date - выводит текущую дату

touch имя_файла - создать пустой файл
touch IMG20{00..18}{00..12}{00..05}.jpg

mkdir имя_папки - создать пустую папку
mkdir  2000 2001 2002 - создать сразу несколько папок
mkdir  20{00..18} - создание  каталогов для годов с 2000 по 2018
mkdir -p путь - создать все недостающие директории в иерархии
mkdir -p 20{00..18}/{01..12} - создание каталогов и подкаталогов

rmdir имя_папки - удалить пустую папку
mv [откуда] имя_папки/файла [куда] - перемещение папки или файла. 
cp [откуда] имя_папки/файла [куда] - копирование папки или файла
cp имя_папки/* имя_папки - скопировать всё содержимое папки
cp -r - скопировать папку со всем содержимым
cp -f - игнорировать ошибки при копировании
rm папка/имя_файла - удаление файла. Пример: rm two/log3.txt
rm -r имя_папки - удаление папки и её содержимого. Пример: rm -r two
rm -r ./* - удалить содержимое текущей папки
rm -f - позволяет игнорировать ошибки при удалении
rm -i - безопасное удаление. Например: rm -ri one - система будет уведомлять и спрашивать разрешение на удаление файла (y/n)

Скрытые папки и файлы:
.hidden.txt - скрытый файл
.hidden_dir - скрытая папка

cat - вывод в терминал текстовых файлов. Например cat log.txt log1.txt - вывод объединённого содержимого

wc -l file - вывести количество строк
wc -w file - вывести количество слов
wc -c file - вывести количество символов

head имя_файла - вывести первые 10 строк файла
head -n - вывести первые n строк файла(не получится скомбинировать с другими ключами)
head -n 4 - вывести первые 4 строк файла(получится скомбинировать с другими ключами)
head имя_файла | wc -l - выводит количество строк

tail n имя_файла - вывести n последних строк файла
tail -f имя_файла - позволяет выводить новые данные в файле в реальном времени

sort - сортирует входные данные, может делать это в алфавитном (по умолчанию) или числовом (требуется опция '-n') порядке.
sort /etc/passwd печатает содержимое файла, отсортированное в алфавитном порядке
sort -t ":" -k 3 -n /etc/passwd печатает содержимое того же файла, отсортированное в числовом порядке, но a) берет значения для сортировки из 3-го поля 
b) использует ":" в качестве разделителя полей.

less имя_файла - открыть файл в less
- Клавиши "Page Up" и "Page Down" можно использовать для прокрутки страницы
- Есть также возможность поиска по всему содержимому. Для этого нужно нажать "/", затем набрать точный шаблон для поиска, и использовать "n" для перехода к следующему 
вхождению, и "Shift + n" для предыдущего
- По окончании нажмите "q" для выхода

nano имя_файла - открыть файл в редакторе nano
^ - ctrl
vi имя_файла открыть файл в редакторе vi
	нажать кнопку "i" - вход в режим правки
	нажать кнопку "esc" - выход из режима правки
	:w - сохранение файла
	:q - выход из редактора
	:q! - выход без сохранения
	:номер_строки - перевод курсора на номер строки
	/слово - поиск по тексту
	нажать dd - удаление строки
	:u - отменить последнее действие

grep текст имя_файла - поиск текста начиная с указанного каталога
grep -i текст имя_файла - игнорирование регистра
grep -v текст имя_файла - показать только несовпавшие строки
grep -c текст имя_файла - подсчёт строк
grep -R текст папка/ - поиск по директории
grep -P 'regex' имя_файла - поиск с помощью регулярного выражения

egrep - Поиск подстрок в текстовых файлах, особенно в огромных журналах (логах)
egrep "something" file1 file2 ... fileN - найти "something" в файлах
'-i': сделать поиск нечувствительным к регистру символов egrep -i "pattern" /some/file выведет строки, содержащие не только "pattern", но и PATTERN, pAtTeRN и т.д.
'-v': вывести все строки, не соответствующие шаблону
'-l': вывести имена файлов (не строк), в которых найден данный шаблон (если таковые имеются)
'-r': поиск шаблона во всех файлах в заданном каталоге и вывод найденных совпадений строк
egrep -r root /etc выведет все строки из всех файлов в каталоге /etc (и его подкаталогах), содержащие подстроку "root".

find папка -name имя_файла - поиск по имени файла
find папка -name *_file - поиск по частичному названию файла
find папка -type d  - поиск по директориям. Пример: find папка -name -type d -name "one*"
find папка -name "*.mp3" -delete - удалить найденные файлы
find папка -name "*.mp3" -delete -print - вывести удаляемые файлы

echo текст - вывод строки "текст" в консоль
echo текст > file.txt - записать результаты команды в файл
echo текст >> file.txt - дозаписать результаты команды в файл
1> - стандартный вывод(1 можно не ставить т.к. используется по умолчанию)
2> - вывод ошибок команды
ls -l safas ./ 2> file1 1> file2 - ошибки направляем в file1, а остальное в file2
cmd > /tmp/result 2>&1 - Запись &1 означает значение файлового дескриптора 1 (stdout). Поэтому выражение 2>&1 означает, что stderr (2) перенаправляется в то же место, куда был перенаправлен 
stdout (1)

команда | команда - передача вывода одной команды на вход другой
cat my.file | grep -i file
ls | grep file

ps - вывести список процессов
ps x - вывести процессы запущенные не только в терминале
ps u - вывести процессы пользователя
ps au - вывести все процессы терминала
ps aux - вывести все процессы

top - вывести таблицу процессов(обновляется)
kill номер_PID - завершить процесс
kill -g номер_PID - завершить процесс немедленно

ping google.com - отсылка тестовых пакетов
ping -c кол_пакетов - количество пакетов google.com
ping -c 3 -i 5 google.com - отсылка 3 пакетов с интервалом в 5 секунд

hostname - узнать имя в вашем хосте или сети
hostname -i - ip адрес

проверить, открыты ли нужные порты:
telnet <ip> <port>
telnet checkip.dyndns.org 80

ip a - информация о сетевых интерфейсах

curl адресс_сайта - послать GET запрос
curl -L ya.ru - переход по редиректу
curl -verbose - показать доп информацию. Пример curl -L ya.ru --verbose

curl https://reqres.in/api/users?параметры
curl -X POST https://reqres.in/api/login --data "email = peter@klaven" --data "password = 1234"

curl -H "заголовок" отправка запроса с заголовком

ssh пользователь@сервер - доступ на удалённый сервер
exit - выход из удалённого соединения
scp пользователь@сервер:/папка/файл папка - копирование с удалённой машины
scp папка/файл пользователь@сервер:/папка - копирование на удалённу машину

Выполнение команды с несколькими аргументами:
команда | xargs ключи команда 2
echo a b c d e f | xargs find . -name *.new_file | xargs cat

$имя - переменная окружения. Пример:
a = "Hello"
echo $a -> Hello

bash - начать новую сессию
exit - выход из сессии

export имя = значение - экспорт переменной
Чтобы переменная была доступна в любой сессии bash:
echo "A = 'Hello world'" >> ~/.bashrc

имя = $(команда) - записать результат команды в переменную
me = $(whoami)
echo $me -> имя текущего пользователя

alias имя = "команда" - установить alias для команды

source имя - запустить bash скрипт
source bash.run

history - отобразить историю команд
!! - выполнить последнюю команду из истории
!-n - выполнить команду за n команд до последней
ctrl+R - поиск по командам
ifconfig - вывод сетевой информации
uname - инфо о системе
free -  сколько оперативной памяти занято или свободно
df -hT - свободное место на дисках

Как установить приложение

Если вы привыкли к винде, то для вас установка приложения — это скачать некий setup файлик, 
запустить и до упора тыкать «далее-далее-далее». В линуксе все немного по-другому. 
Тут приложения ставятся как пакеты. И для каждой системы есть свой менеджер пакетов:

yum — red hat, centos
dpkg, apt — debian

Например: yum install mc


Как запустить приложение

Некоторые приложения запускаются через скрипты. Например, чтобы запустить сервер приложения WildFly, 
нужно перейти в папку bin и запустить там standalone.sh. Файл с расширением .sh — это скрипт.

Чтобы запустить скрипт, нужно указать полный путь к нему:

/opt/cdi/jboss/bin/standalone.sh — запустили скрипт standalone.sh

Это важно! Даже если вы находитесь в той папке, где и скрипт, он не будет найден, если просто 
указать название sh-скрипта. Надо написать так:

./standalone.sh — запустили скрипт, если мы в той же директории

Поиск идет только в каталогах, записанных в переменную PATH. Так что если скрипт используется часто, 
добавляйте путь туда и вызывайте просто по названию:

standalone.sh --- запустили скрипт standalone.sh, путь к которому прописан в PATH

Если же приложение запускается как сервис, то все еще проще:

service test start — запустить сервис под названием «test»
service test stop — остановить сервис

Чтобы сервис test запускался автоматически при рестарте системы, используйте команду:

chkconfig test on

Она добавит службу в автозапуск.

Чтобы узнать, куда приложение установилось, используйте whereis (без пробела):

whereis newman

Как создать архив

Стандартная утилита, которая будет работать даже на «голой» системе — tar. 
Правда, для ее использования надо запомнить флаги. Для создания архива стандартная комбинация cvzf:

tar -cvzf archive.tar.gz /home/test

Для распаковки меняем флаг «c» на «x» и убираем «z»:

tar -xvf archive.tar.gz

Хотя система пишет, что распаковала «/home/test», на самом деле папка «test» появляется там, где мы сейчас находимся.

Давайте разберемся, что все эти флаги означают:

c — создать архив в linux
x — извлечь файлы из архива
v — показать подробную информацию о процессе работы (без него мы бы не увидели, какие файлики запаковались / распаковались)
f — файл для записи архива
z — сжатие

Для упаковки используется опция c — Create, а для распаковки x — eXtract.

zip - сжатие файла в zip архив
unzip - извлечение файла из zip архива


=======================================================================Права пользователей=====================================================================================
По сути 2 вида: root и все остальные. root не имеет никаких ограничений. 
У root uid = 0. Пользователи с uid равным от 1 до 999 являются служебными пользователями, демонами(от их имени запускаются службы)

Есть права для владельца файла, для группы владельца файла(gid), права для тех кто не является владельцем и не входит в группу владельца
В выводе ls -l начиная со второго символа (-|d|l)rwx(права владельца)rwx(права для группы владельца)rwx(для всех остальных) name(имя владельца) name(имя группы владельца)
Плюс в конце строчки прав означает, что используются ACL, можно их посмотреть командой getfacl

Типы прав:
r - чтение
w - запись
x - исполнение(если файл является папкой, то возможность зайти в неё)

cat /etc/passwd - информация о пользователях
root(имя пользователя):x(раньше здесь был пароль):0(uid):0(gid):root(комментарий):/root(домашний каталог):/bin/bash(командная оболочка при входе на сервер)

cat /etc/group - информация о группах
adm(название группы):x:4(gid):syslog,mamalazer(кто присутствует в группе)

cat /etc/shadow - хранятся хеши паролей

chmod o-r err - убрать права на чтение файла err для всех остальных(кроме текущего пользователя и его группы)
chmod u-w err - убрать права на запись файла err для текущего пользователя
chmod u+w err - дать права на запись файла err для текущего пользователя
chmod +w err - дать права на запись файла err для текущего пользователя и его группы
chmod -w err - убрать права на запись файла err для текущего пользователя и его группы
chmod u+rwx,g+rw,o-rwx ./err - работа с правами сразу для текущего пользователя, его группы и всех остальных
u — владелец,
g — группа,
o — остальные,
a — для всех (ugo)

Если у файла права rwx r–x r– –,  то
chmod +w myfile задаст права rwx rwx rw –.
chmod =w myfile задаст права –w–  –w– –w –.

также можно использовать числовой chmod. rw-r--r-- этот набор прав можно представить в двоичной системе 110100100(1 - есть право, 0 - нет), а затем перевести в восьмиричную и 
использовать команду: chmod 644 err
чтобы легко переводить в восмеричную систему r = 4, w = 2, x = 1 т.е. 111100100 это 4 + 2 + 1_4 + 0 + 0_4 + 0 + 0 = 744

r - read (чтение)
файлы: Файл может быть прочитан, например, с помощью cat, less, head, других инструментов.
папки: Список содержимого каталога может быть прочитан. Если бит 'x' не установлен, могут быть прочитаны только имена объектов.

w - write (запись)
файлы: Содержимое файла может быть изменено. Но сам файл не может быть удален - см. 'w' для каталогов.
папки: Любой элемент этого каталога может быть создан или удален. То есть, даже если вы не являетесь владельцем файла в этом каталоге, вы можете удалить его, 
установив 'w' для каталога. Это можно сделать только в том случае, если бит "x" также установлен.

x - execute (выполнение)
файлы: Файл может быть выполнен. Фактически исполняемые файлы: двоичные файлы и скрипты
папки: Самый важный бит для каталогов. Вы можете войти в этот каталог (например, с помощью "cd") и получить доступ (чтение, запись, выполнение) ко всему его содержимому, 
если это разрешено их правами доступа. Если у вас нет 'x' для каталога, вы НЕ можете:
- переходить в подкаталоги
- создавать/удалять объекты (файлы, каталоги)
- читать информацию об объекте (разрешения, владелец, ...)

su - user_name - используется для запуска оболочки от имени другого пользователя (по умолчанию root) после предоставления пароля пользователя
exit - вернуться к предыдущему пользователю
Всегда лучше использовать "su -" вместо "su", так как ключ "-" загружает все окружение оболочки целевого пользователя

Чтобы проверить возможности пользователя
sudo -l

Чтобы запустить команды
sudo [-u username] command args

========================================================================Создание пользователей и групп=========================================================================
groupadd developer - создать группу developer

useradd -m -G developer -s /bin/bash ivanov - создать пользователя
-m — также создать домашний каталог. По умолчанию каталог создаётся в /home с именем учётной записи, например, /home/ivanov. 
Если надо создать нестандартный каталог, можно указать его, используя параметр параметра -d. 
-G — список групп, к которым принадлежит создаваемый пользователь. По умолчанию также создается персональная группа пользователя с именем учётной записи. 
Она является первичной и по умолчанию все файлы пользователя создаются с этой группой в качестве группы-владельца. 
-s — задает оболочку пользователя. Для обычных пользователей обычно это /bin/bash. Для ftp/sftp-пользователей и системных псевдопользователей на этом месте указывается 
псевдооболочка, например, /usr/sbin/nologin или /bin/false. 

По умолчанию для новых учетных записей без пароля заблокирован вход в систему, поэтому установим пароль для пользователей с помощью passwd, например:
passwd petrov

Есть альтернативный способ создания пользователя.
adduser smirnov

Если нам понадобится изменить параметры для уже созданного пользователя, поможет утилита usermod. Параметры аналогичны утилите useradd. Также её можно использовать для 
блокировки/разблокировки пользователей. Опция -L позволит заблокировать учётную запись. Операция блокировки добавляет символ «!» в начало пароля в файле /etc/shadow. 
Параметр -U снимает блокировку. Для удаления учётной записи предназначена утилита userdel. Полезный ключ -r удаляет из системы домашний каталог пользователя. 

===================================================================================Ссылки=====================================================================================
В отличие от системы FAT (например, exFAT часто используется на флешках), в Linux принята организация файловых систем с отдельным хранением атрибутов. Каталог ссылается не 
сразу на файл, а на айнод (i-node), содержащий атрибуты (метаинформацию о файле) и ссылающийся на файлы. 

ln file_name link_name - создать хардлинк для файла, хардлинк будет иеметь такие же права доступа. 
Файл хранится в определённой области памяти, хардлинк тоже ссылается на эту область памяти, по сути это ещё одно имя файла(области памяти)
Нельзя сделать хардлинк с одно диска на другой т.к. i ноды на другом диске могут принадлежать другому файлу
Нельзя создать для директории
Хардлинк и файл занимают одну и ту же i ноду (ls -li цифры в начале строки)
Если удалить файл, то хардлинк всё равно останется

ln -s file_name link_name - создать софтлинк
Софтлинк - ярлык файла. Имеет свою i ноду
Если удалить файл на который ссылается софтлинк, то софтлинк останется, но будет ссылаться на пустоту

=======================================================================Bash программирование====================================================================================

Чтобы присвоить переменной значение, используется запись: myvar=example

Если мы хотим присвоить значение, содержащее пробелы, необходимо либо экранировать пробелы, либо заключить все выражение в кавычки:

myvar2=example\ with\ long\ string
myvar3=" very long long string"

Чтобы использовать значение переменной, необходимо в начале переменной использовать $:

echo $myvar
echo $myvar1
echo $myvar2

Регистр важен: myvar и MyVar разные значения.

Чтобы точно указать границы переменной, можно использовать фигурные скобки:

echo ${myvar}12

Переменные, созданные во время действия сессии, вы можете использовать. Но если вы запустите новую копию bash, там они действовать не будут. Чтобы сделать переменные 
доступными для дочерней сессии, необходимо использовать export:

export test=hello
echo $test
exit
echo $test

Переменная $? хранит последний код возврата

echo $?

0 - успешный код возврата(true)

ls -l && echo OK - логическое И, если обе программы вернули код 0, то будут выполнены обе команды. В обратном случае ниодна не будет выполнена
ls -l || echo OK - логическое ИЛИ, если левая часть вернула код 0, то правая выполняться не будет и наоборот. Если обе части не вернут код 0, то не выполнится ниодна из частей
ls -l ; echo OK - выполнять все команды вне зависимости от того, какой код они возвращают

==================================================================================Циклы=========================================================================================

for i in {2015..2020}; do echo $i; done - цикл

for i in {2015..2020}; do echo $i; for y in {01..122}; do echo $y done; done - цикл в цикле

Есть возможность использования for более привычным для программиста способом:

#!/bin/bash
for (( c=1; c<=5; c++ ))
do  
   echo "Попытка номер $c"
done


Если необходимо перейти сразу к следующей итерации, используется continue:

#!/bin/bash
for f in *
do
        # если копия .bak есть то будем читать следующий файл
	if [ -f ${f}.bak ]
	then
		echo "Skiping $f file..."
		continue  # переходим к следующей итерации
	fi
        # архива нет, копируем
	/bin/cp $f $f.bak
done

Если необходимо прервать цикл, используется break:

#!/bin/bash
for d in $*
do
#для каждого из аргументов пытаемся создать директорию,
#если хотя бы раз не получилось, выходим из цикла
         mkdir $d||break
done

Можно использовать фигурные скобки:

#!/bin/bash
for d in $*
do
#для каждого из аргументов пытаемся создать директорию
#если хотя бы раз не получилось, выходим из цикла
         mkdir $d||{
                         echo Недостаточно прав, останавливаемся
                             break
                             #а если надо выйти из программы, используем exit с кодом ошибки
                         }
done


===========================================================================Условный оператор====================================================================================

if условие
then
действия
else
действия в противном случае
fi

Пример: testleap.sh — високосный ли год сейчас:

#!/bin/bash
year=`date +%Y`
if [ $[$year % 400] -eq 0 ]; then
  echo "Это високосный год. В феврале 29 дней."
elif [ $[$year % 4] -eq 0 ]; then
        if [ $[$year % 100] -ne 0 ]; then
            echo "Это високосный год. В феврале 29 дней."
        else
          echo "Это не високосный год. В феврале 28 дней."
        fi
else
 echo "Это не високосный год. В феврале 28 дней."
fi

[ позволяет делать проверки:
●	== равенство;
●	!= неравенство;
●	-lt меньше;
●	-gt больше;
●	-lte меньше или равно;
●	-gte больше или равно;
●	-f  файл;
●	-d директория;
●	и некоторые другие.

Для удобства можно использовать более новый инструмент [[. 
В отличие от [, это не программа. [[ не разбивает значения переменных на несколько слов, понимает более привычные для других языков способы записи.

if [[ 2 < 3 ]]
then
   echo Yes
fi

==============================================================================Скрипты===========================================================================================

Чтобы создать скрипт, необходимо создать файл с разрешением .sh(так принято) и добавить в него необходимые команды. Для запуска необходимо предоставить права на исполнение этому 
файлу с помощью chmod a+x file.sh. Чтобы скрипт мог выполняться с помощью различных интерпритаторов, необходимо в первой строчке файла со скриптом указать нужный интерпритатор, 
например, #!/bin/bash(указывть только абсолютный путь)

Существуют следующие варианты сравнения:

●	-lt — меньше;
●	-gt — больше;
●	-lte — меньше или равно;
●	-gte — больше или равно.

#!/bin/bash
[ $# -lt 3 ]&&echo Параметров не может быть меньше трех

А если нам хочется сделать несколько действий? Группы команд можно сгруппировать в фигурные скобки:
#!/bin/bash
[ $# -lt 3 ]&&{
                     echo Параметров не может быть меньше трех
                     echo Формат использования
                     echo $0 arg1 arg2 arg3
                     exit 1
}

$0 содержит имя скрипта. 

Есть в bash и условный оператор:

#!/bin/bash
if [ $# -lt 3 ]
then
                     echo Параметров не может быть меньше трех
                     echo Формат использования
                     echo $0 arg1 arg2 arg3
                     exit 1
else
                     echo все хорошо, продолжаем
                     ln $1 $2
                     ln -s $1 $3   

fi

Фигурные скобки в данном случае не нужны.
fi — наследие языка Алгол 68,там действительно if заканчивался на fi.

Есть в bash и вариант с множественным выбором case. Заканчивается он оригинально c помощью esac. Обратите внимание, после каждого варианта следует ;;.
Общий формат: 

case выражение in
значение1) действия;;
значения2)действия;;
значения3)действия;;
..
esac
Пример:

#!/bin/bash
LOG=~/usefullscripts/monitor/logfile 
tail -0f "${LOG}" |     while read i     
do      
 case $i in     
       "err1")     
 zenity --info --text="В журнале  ошибка 1" ;;
 "err2") 
 zenity --info --text="В журнале  ошибка 2" ;; 
 "err3")   
 zenity --info --text="В журнале  ошибка 3" ;;   
 esac  
done 

Допустим, надо написать учебную утилиту, которая выводит на экран первые три параметра.

./myprint test1 test2 test3
Должно выдать результат:

test1 test2 test3

Для получения значений параметров есть специальные переменные $1, $2, $3 и так далее до $9. Есть и переменные для аргументов, следующих за девятым. Но их надо брать в фигурные 
скобки, например, ${10}

Переменная $0 содержит имя запущенной программы

#!/bin/bash
echo Usage:
echo $0 arg1 arg2 ...

Если нам важно число аргументов, есть специальная переменная $#, которая хранит количество параметров.


=======================================================================Арифметические операции=================================================================================
Как вы догадались, в результате выполнения команд:

a=3
b=4
с=$a+$b
echo "a+b= $c" 

Выведет:
a+b=3+4

Всё потому, что bash прежде всего ориентирован на работу со строками. Для использования арифметики необходимо задействовать команду let:

a=3
b=4
let "c=a+b" 
echo "a+b= $c" 

Выведет:
a+b=7

Пример использования разных операций:

#!/bin/bash
#Прочитаем с клавиатуры a и b
echo "Введите a: "
read a
echo "Введите b: "
read b
let "c = a + b"  #сложение
echo "a+b= $c"
let "c = a * b"  #умножение
echo "a*b= $c"
let "c = a ** b" #возведение в степень
echo "a^b= $c"
let "c = a / b"   #деление
echo "a/b= $c"
let "c <<= 2"    #сдвигает c на 2 разряда влево
echo "c после сдвига на 2 разряда: $c"
let "c = a % b" # находит остаток от деления a на b
echo "$a / $b. остаток: $c "

Возможны и сокращенные формы записи. Увеличить a на пять:

let  "a += 5"

Умножить a на пять:

let  "a *= 5"

bash не умеет работать с дробными числами. Значения с точкой или запятой будут восприниматься как строки. Если очень нужно использовать арифметику с плавающей точкой, 
используют b или сразу пишут скрипты на Python или Perl.

Кроме let, есть команда expr. В отличие от let, она сразу выводит на экран результат. Используются переменные с указанием $, обязательны пробелы и кавычки не нужны:

a=3
b=1
expr $a + $b

expr умеет работать и  с логическими операторами, например, < или > но их надо экранировать:

a=3
b=1
expr $a \> $b

Чтобы присвоить результат выражения, можно использовать:

a=3
b=1
c=`expr $a + $b`

Но для этого есть более удобная форма записи с помощью конструкции $(( )):

a=3
b=1
c=$(($a + $b))

И для того же есть еще более удобная форма записи с помощью конструкции $[ ]:

a=3
b=1
c=$[$a + $b]


=========================================================================Шаблоны подстановки===================================================================================

Обратите внимание, что, в отличие от ~,~- и ~+, пути . и .. не являются подстановками. По сути, это специфические жесткие ссылки на текущую и вышестоящую директории, что легко 
проверить с помощью команды ls с ключом -il.
Во что превращаются подстановки, можно проверить с помощью команды echo:

echo ~
Чем-то похоже на регулярные выражения, но не стоит путать. Например, один любой символ в регулярных выражениях обозначается как ., а в подстановках — как ?. Любое число 
символов в регулярных выражениях обозначается как .*, а в подстановках — как *.

Создадим три файла file1,file2,file3:

touch file1
touch file2
touch file3
echo file?

Вывести список всех пятисимвольных файлов в текущей директории: echo ????? - 

Вывести список всех файлов, которые начинаются с буквы b: echo b*

Скопировать все файлы, которые начинаются с b в директорию folder: cp b* folder/

Просто * заменяется на перечень всех файлов, присутствующих в директории: echo *

Но если директория пустая, подстановка произведена не будет:

mkdir empty
cd empty
echo *
*

Вместо любого символа ? можно указать символ из диапазона.
В шаблонах подстановки существуют и перечисления. Выглядят аналогично регулярным выражениям:

echo file?
file1 file2 file 3 file4 filea fileb

echo file[1-2]
file 1 file2

echo file[^1-2]
file 3 file4 filea fileb

Как вы догадались, [^диапазон] означает любой символ, кроме указанных в диапазоне.

Подстановка * выводит список файлов в текущей директории или звездочку, если директория пуста. Для того, чтобы вывести список из чего-то другого, кроме файлов из текущей 
директории, можно задать перечень. Сравните:

echo {1..12}
echo {01..12}
echo {21..01}
echo {21..1}

Обратите внимание, что соблюдается не только порядок, но и число знаков. Можно использовать для создания файлов. 
То есть действия выше можно было записать короче: touch file{1..3}

Можно создать директории: mkdir -p foto{2001..2017}/{01..12}

Можно использовать перечисления не только из чисел, но и символов:

echo {a..f}
echo {f..a}

Можно использовать несколько значений через запятую: echo {a,c,e}

ДЗ
1) Написать скрипт, который удаляет из текстового файла пустые строки и заменяет маленькие символы на большие (воспользуйтесь tr или sed).

#!/bin/bash

text=$(cat $1 | tr -d [:space:] | [:lower:] [:upper:])
echo $text > $1

2( Создать скрипт, который создаст директории для нескольких годов (2010 — 2017), в них — поддиректории для месяцев (от 01 до 12), и в каждый из них запишет несколько файлов с 
произвольными записями (например 001.txt, содержащий текст Файл 001, 002.txt с текстом Файл 002) и т.д.

#!/bin/bash

num=1

for year in {2010..2017}
do
	for month in {01..12}
	do
		path=./${year}/${month}
		mkdir -p ${path}
		touch ${path}/${num}.txt
		echo "файл ${num}" > ${path}/${num}.txt
		let "num += 1"
	done
done 